//
// Created by lianglei on 2022/11/18.
//

#include <string>

#ifndef PBRSHADERSTRINGS_H
#define PBRSHADERSTRINGS_H

namespace PbrShaderStrings {
    const static std::string shaderbrdfVetex = "#version 300 es\n"
                                               "precision highp float;\n"
                                               "layout (location = 0) in vec2 aPos;\n"
                                               "layout (location = 3) in vec2 aTexCoords;\n"
                                               "\n"
                                               "out vec2 TexCoords;\n"
                                               "\n"
                                               "void main()\n"
                                               "{\n"
                                               "    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); \n"
                                               "    TexCoords = aTexCoords;\n"
                                               "} \n";
    const static std::string shaderbrdfFrag = "#version 300 es\n"
                                              "precision highp float;\n"
                                              "out vec2 FragColor;\n"
                                              "in vec2 TexCoords;\n"
                                              "\n"
                                              "const float PI = 3.14159265359;\n"
                                              "\n"
                                              "float RadicalInverse_VdC(uint bits) \n"
                                              "{\n"
                                              "     bits = (bits << 16u) | (bits >> 16u);\n"
                                              "     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n"
                                              "     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n"
                                              "     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n"
                                              "     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n"
                                              "     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n"
                                              "}\n"
                                              "\n"
                                              "vec2 Hammersley(uint i, uint N)\n"
                                              "{\n"
                                              "	return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n"
                                              "}\n"
                                              "\n"
                                              "vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n"
                                              "{\n"
                                              "	float a = roughness*roughness;\n"
                                              "	\n"
                                              "	float phi = 2.0 * PI * Xi.x;\n"
                                              "	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n"
                                              "	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n"
                                              "	\n"
                                              "	// from spherical coordinates to cartesian coordinates - halfway vector\n"
                                              "	vec3 H;\n"
                                              "	H.x = cos(phi) * sinTheta;\n"
                                              "	H.y = sin(phi) * sinTheta;\n"
                                              "	H.z = cosTheta;\n"
                                              "	\n"
                                              "	// from tangent-space H vector to world-space sample vector\n"
                                              "	vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n"
                                              "	vec3 tangent = normalize(cross(up, N));\n"
                                              "	vec3 bitangent = cross(N, tangent);\n"
                                              "	\n"
                                              "	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n"
                                              "	return normalize(sampleVec);\n"
                                              "}\n"
                                              "\n"
                                              "float GeometrySchlickGGX(float NdotV, float roughness)\n"
                                              "{\n"
                                              "    float a = roughness;\n"
                                              "    float k = (a * a) / 2.0;\n"
                                              "\n"
                                              "    float nom   = NdotV;\n"
                                              "    float denom = NdotV * (1.0 - k) + k;\n"
                                              "\n"
                                              "    return nom / denom;\n"
                                              "}\n"
                                              "\n"
                                              "float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n"
                                              "{\n"
                                              "    float NdotV = max(dot(N, V), 0.0);\n"
                                              "    float NdotL = max(dot(N, L), 0.0);\n"
                                              "    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n"
                                              "    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n"
                                              "\n"
                                              "    return ggx1 * ggx2;\n"
                                              "}\n"
                                              "\n"
                                              "vec2 IntegrateBRDF(float NdotV, float roughness)\n"
                                              "{\n"
                                              "    vec3 V;\n"
                                              "    V.x = sqrt(1.0 - NdotV*NdotV);\n"
                                              "    V.y = 0.0;\n"
                                              "    V.z = NdotV;\n"
                                              "\n"
                                              "    float A = 0.0;\n"
                                              "    float B = 0.0; \n"
                                              "\n"
                                              "    vec3 N = vec3(0.0, 0.0, 1.0);\n"
                                              "    \n"
                                              "    const uint SAMPLE_COUNT = 1024u;\n"
                                              "\n"
                                              "    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\n"
                                              "        // generates a sample vector that's biased towards the\n"
                                              "        // preferred alignment direction (importance sampling).\n"
                                              "        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n"
                                              "        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n"
                                              "        vec3 L = normalize(2.0 * dot(V, H) * H - V);\n"
                                              "\n"
                                              "        float NdotL = max(L.z, 0.0);\n"
                                              "        float NdotH = max(H.z, 0.0);\n"
                                              "        float VdotH = max(dot(V, H), 0.0);\n"
                                              "\n"
                                              "        if(NdotL > 0.0) {\n"
                                              "            float G = GeometrySmith(N, V, L, roughness);\n"
                                              "            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n"
                                              "            float Fc = pow(1.0 - VdotH, 5.0);\n"
                                              "\n"
                                              "            A += (1.0 - Fc) * G_Vis;\n"
                                              "            B += Fc * G_Vis;\n"
                                              "        }\n"
                                              "    }\n"
                                              "\n"
                                              "    A /= float(SAMPLE_COUNT);\n"
                                              "    B /= float(SAMPLE_COUNT);\n"
                                              "    return vec2(A, B);\n"
                                              "}\n"
                                              "\n"
                                              "void main() \n"
                                              "{\n"
                                              "    vec2 integratedBRDF = IntegrateBRDF(TexCoords.x, TexCoords.y);\n"
                                              "    FragColor = integratedBRDF;\n"
                                              "}";

    const static std::string shaderCubeMapVert = "#version 300 es\n"
                                                 "precision highp float;\n"
                                                 "layout (location = 0) in vec3 aPos;\n"
                                                 "\n"
                                                 "out vec3 FragPos;\n"
                                                 "\n"
                                                 "uniform mat4 projection;\n"
                                                 "uniform mat4 view;\n"
                                                 "\n"
                                                 "void main()\n"
                                                 "{\n"
                                                 "    FragPos = aPos;  \n"
                                                 "    gl_Position =  projection * view * vec4(FragPos, 1.0);\n"
                                                 "}";
    const static std::string shaderCubeMapFrag = "#version 300 es\n"
                                                 "precision highp float;\n"
                                                 "layout (location = 0) in vec3 aPos;\n"
                                                 "\n"
                                                 "out vec3 FragPos;\n"
                                                 "\n"
                                                 "uniform mat4 projection;\n"
                                                 "uniform mat4 view;\n"
                                                 "\n"
                                                 "void main()\n"
                                                 "{\n"
                                                 "    FragPos = aPos;  \n"
                                                 "    gl_Position =  projection * view * vec4(FragPos, 1.0);\n"
                                                 "}";

    const static std::string shaderequirectangularFrag = "#version 300 es\n"
                                                         "precision highp float;\n"
                                                         "out vec4 FragColor;\n"
                                                         "in vec3 FragPos;\n"
                                                         "\n"
                                                         "uniform sampler2D equirectangularMap;\n"
                                                         "\n"
                                                         "const vec2 invAtan = vec2(0.1591, 0.3183);\n"
                                                         "\n"
                                                         "vec2 SampleSphericalMap(vec3 v)\n"
                                                         "{\n"
                                                         "    vec2 uv = vec2(atan(v.z, v.x), asin(v.y));\n"
                                                         "    uv *= invAtan;\n"
                                                         "    uv += 0.5;\n"
                                                         "    return uv;\n"
                                                         "}\n"
                                                         "\n"
                                                         "void main()\n"
                                                         "{		\n"
                                                         "    vec2 uv = SampleSphericalMap(normalize(FragPos));\n"
                                                         "    vec3 color = texture(equirectangularMap, uv).rgb;\n"
                                                         "    \n"
                                                         "    FragColor = vec4(color, 1.0);\n"
                                                         "}";

    const static std::string shaderirradianceFrag = "#version 300 es\n"
                                                    "precision highp float;\n"
                                                    "out vec4 FragColor;\n"
                                                    "in vec3 FragPos;\n"
                                                    "\n"
                                                    "uniform samplerCube environmentMap;\n"
                                                    "\n"
                                                    "const float PI = 3.14159265359;\n"
                                                    "\n"
                                                    "void main()\n"
                                                    "{		\n"
                                                    "    vec3 N = normalize(FragPos);\n"
                                                    "\n"
                                                    "    vec3 irradiance = vec3(0.0);   \n"
                                                    "    \n"
                                                    "    // tangent space calculation from origin point\n"
                                                    "    vec3 up = vec3(0.0, 1.0, 0.0);\n"
                                                    "    vec3 right = cross(up, N);\n"
                                                    "    up = cross(N, right);\n"
                                                    "       \n"
                                                    "    float sampleDelta = 0.025;\n"
                                                    "    float nrSamples = 0.0;\n"
                                                    "\n"
                                                    "    for(float phi = 0.0; phi < 2.0 * PI; phi += sampleDelta) {\n"
                                                    "        for(float theta = 0.0; theta < 0.5 * PI; theta += sampleDelta) {\n"
                                                    "            // spherical to cartesian (in tangent space)\n"
                                                    "            vec3 tangentSample = vec3(sin(theta) * cos(phi),  sin(theta) * sin(phi), cos(theta));\n"
                                                    "            // tangent space to world\n"
                                                    "            vec3 sampleVec = tangentSample.x * right + tangentSample.y * up + tangentSample.z * N; \n"
                                                    "\n"
                                                    "            irradiance += texture(environmentMap, sampleVec).rgb * cos(theta) * sin(theta);\n"
                                                    "            nrSamples++;\n"
                                                    "        }\n"
                                                    "    }\n"
                                                    "\n"
                                                    "    irradiance = PI * irradiance * (1.0 / float(nrSamples));\n"
                                                    "    \n"
                                                    "    FragColor = vec4(irradiance, 1.0);\n"
                                                    "}";
    const static std::string shaderpbrVert = "#version 300 es\n"
                                             "precision highp float;\n"
                                             "\n"
                                             "layout(location = 0) in vec3 aPos;\n"
                                             "layout(location = 1) in vec3 aNormal;\n"
                                             "layout(location = 2) in vec3 aTangent;\n"
                                             "layout(location = 3) in vec2 aTexCoords;\n"
                                             "\n"
                                             "out vec3 Normal;\n"
                                             "out vec2 TexCoords;\n"
                                             "out vec3 TangentViewDir;\n"
                                             "out vec3 TangentFragPos;\n"
                                             "out vec3 TangentLightPos;\n"
                                             "out mat3 iTBN;\n"
                                             "\n"
                                             "uniform mat4 model;\n"
                                             "uniform mat4 view;\n"
                                             "uniform mat4 projection;\n"
                                             "uniform mat3 normalMat;\n"
                                             "uniform vec3 eyePos;\n"
                                             "uniform vec3 lightPos;\n"
                                             "uniform vec2 textureScale;\n"
                                             "uniform sampler2D displacementMap;\n"
                                             "uniform float displacementAmount;\n"
                                             "\n"
                                             "void main()\n"
                                             "{\n"
                                             "	TexCoords = aTexCoords * textureScale;\n"
                                             "	vec3 Position = aPos;\n"
                                             "\n"
                                             "	if (displacementAmount > 0.0) {\n"
                                             "		float k = texture(displacementMap, TexCoords).r * displacementAmount;\n"
                                             "		Position = Position + aNormal * k;\n"
                                             "	}\n"
                                             "\n"
                                             "	gl_Position = projection * view * model * vec4(Position, 1.0);\n"
                                             "\n"
                                             "	vec3 T = normalize(vec3(normalMat * aTangent));\n"
                                             "	vec3 N = normalize(vec3(normalMat * aNormal));\n"
                                             "	vec3 B = cross(N, T);\n"
                                             "\n"
                                             "	Normal = N;\n"
                                             "	mat3 TBN = transpose(mat3(T, B, N));\n"
                                             "\n"
                                             "	vec3 FragPos = vec3(model * vec4(Position, 1.0));\n"
                                             "	TangentFragPos = TBN * FragPos;\n"
                                             "\n"
                                             "	TangentViewDir = TBN * (eyePos - FragPos);\n"
                                             "\n"
                                             "\n"
                                             "	TangentLightPos = TBN * lightPos;\n"
                                             "\n"
                                             "	iTBN = inverse(TBN);\n"
                                             "}";

    const static std::string shaderpbrFrag = "#version 300 es\n"
                                             "precision highp float;\n"
                                             "\n"
                                             "#define PI 3.1415926535897932384626433832795\n"
                                             "\n"
                                             "in vec3 Normal;\n"
                                             "in vec2 TexCoords;\n"
                                             "in vec3 TangentViewDir;\n"
                                             "in vec3 TangentFragPos;\n"
                                             "in vec3 TangentLightPos;\n"
                                             "in mat3 iTBN;\n"
                                             "\n"
                                             "out vec4 FragColor;\n"
                                             "\n"
                                             "uniform sampler2D albedoMap;\n"
                                             "uniform sampler2D normalMap;\n"
                                             "uniform sampler2D metallicMap;\n"
                                             "uniform sampler2D roughnessMap;\n"
                                             "uniform sampler2D aoMap;\n"
                                             "uniform sampler2D brdfLUT;\n"
                                             "uniform samplerCube irradianceMap;\n"
                                             "uniform samplerCube environmentMap;\n"
                                             "uniform samplerCube preFilterMap;\n"
                                             "uniform float heightScale;\n"
                                             "uniform bool lightEnabled;\n"
                                             "\n"
                                             "// Trowbridge-Reitz GGX normal distribution function\n"
                                             "float DistributionGGX(vec3 N, vec3 H, float roughness);\n"
                                             "\n"
                                             "// Smith's Schlick-GGX geometry function\n"
                                             "float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness);\n"
                                             "float GeometrySchlickGGX(float NdotV, float roughness);\n"
                                             "\n"
                                             "//Fresnel-Schlick Fresnel equation\n"
                                             "vec3 fresnelSchlick(float cosTheta, vec3 F0);\n"
                                             "vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness);\n"
                                             "\n"
                                             "void main()\n"
                                             "{\n"
                                             "	vec2 texCoords = TexCoords;\n"
                                             "\n"
                                             "    vec3 albedo = texture(albedoMap, texCoords).rgb;\n"
                                           //  "    vec3 albedo = pow(texture(albedoMap, texCoords).rgb, vec3(2.2));\n"
                                             "    float metallic =texture(metallicMap, texCoords).r;\n"
                                            // "    float metallic =1.0 - texture(metallicMap, texCoords).r;\n"
                                             "    float roughness = texture(roughnessMap, texCoords).r;\n"
                                             "    float ao = texture(aoMap, texCoords).r;\n"
                                             "\n"
                                             "	vec3 lightColor = vec3(2.0, 2.0, 2.0);\n"
                                             "\n"
                                             "	vec3 N = texture(normalMap, texCoords).rgb;\n"
                                             "	N = normalize(N * 2.0 - 1.0);\n"
                                             "    vec3 V = normalize(TangentViewDir);\n"
                                             "	vec3 R = reflect(-V, N);\n"
                                             "\n"
                                             "	vec3 F0 = vec3(0.04); \n"
                                             "	F0 = mix(F0, albedo, metallic);\n"
                                             "	vec3 Lo = vec3(0.0);\n"
                                             "\n"
                                             "	// PointLight\n"
                                             "	if (lightEnabled) {\n"
                                             "		vec3 L = normalize(TangentLightPos - TangentFragPos);\n"
                                             "		vec3 H = normalize(V + L);\n"
                                             "\n"
                                             "		float distance = length(TangentLightPos - TangentFragPos);\n"
                                             "		float attenuation = 1.0 / (distance * distance);\n"
                                             "		vec3 radiance = lightColor * attenuation;\n"
                                             "\n"
                                             "		// Fresnel equation\n"
                                             "		vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n"
                                             "		// Normal distribution function\n"
                                             "		float D = DistributionGGX(N, H, clamp(roughness, 0.025, 1.0));\n"
                                             "		// Geometry function\n"
                                             "		float G = GeometrySmith(N, V, L, clamp(roughness, 0.025, 1.0));\n"
                                             "\n"
                                             "		//Cook-Torrance BRDF\n"
                                             "		vec3 numerator    = D * G * F;\n"
                                             "		float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n"
                                             "		vec3 specular     = numerator / max(denominator, 0.001);\n"
                                             "\n"
                                             "		vec3 kS = F;\n"
                                             "		vec3 kD = vec3(1.0) - kS;\n"
                                             "		kD *= 1.0 - metallic;\n"
                                             "\n"
                                             "		float NdotL = max(dot(N, L), 0.0);\n"
                                             "		Lo += (kD * albedo / PI + specular) * radiance * NdotL;\n"
                                             "	}\n"
                                             "\n"
                                             "    // IBL\n"
                                             "	vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, roughness);\n"
                                             "	vec3 kS = F;\n"
                                             "	vec3 kD = 1.0 - kS;\n"
                                             "	kD *= 1.0 - metallic;\n"
                                             "	vec3 worldSpaceNormal = iTBN * N;\n"
                                             "	vec3 worldSpaceReflect = iTBN * R;\n"
                                             "	vec3 irradiance = texture(irradianceMap, worldSpaceNormal).rgb;\n"
                                             "	vec3 diffuse = irradiance * albedo;\n"
                                             "\n"
                                             "	const float MAX_REFLECTION_LOD = 4.0;\n"
                                             "	vec3 prefilteredColor = textureLod(preFilterMap, worldSpaceReflect,  roughness * MAX_REFLECTION_LOD).rgb;   \n"
                                             "	vec2 envBRDF  = texture(brdfLUT, vec2(max(dot(N, V), 0.0), roughness)).rg;\n"
                                             "	vec3 specular = prefilteredColor * (F * envBRDF.x + envBRDF.y);\n"
                                             "\n"
                                             "	vec3 ambient = (kD * diffuse + specular)*(ao+0.1);\n"
                                             "    \n"
                                             "    vec3 color = ambient + Lo;\n"
                                             "\n"
                                             "	FragColor = vec4(color, 1.0);\n"
                                             "}\n"
                                             "\n"
                                             "float DistributionGGX(vec3 N, vec3 H, float roughness)\n"
                                             "{\n"
                                             "    float a = roughness*roughness;\n"
                                             "    float a2 = a*a;\n"
                                             "    float NdotH = max(dot(N, H), 0.0);\n"
                                             "    float NdotH2 = NdotH*NdotH;\n"
                                             "\n"
                                             "    float nom   = a2;\n"
                                             "    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
                                             "    denom = PI * denom * denom;\n"
                                             "\n"
                                             "    return nom / denom; // prevent divide by zero for roughness=0.0 and NdotH=1.0\n"
                                             "}\n"
                                             "\n"
                                             "float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)\n"
                                             "{\n"
                                             "	roughness = clamp(roughness, 0.01, 1.0);\n"
                                             "    float NdotV = max(dot(N, V), 0.0);\n"
                                             "    float NdotL = max(dot(N, L), 0.0);\n"
                                             "    float ggx2 = GeometrySchlickGGX(NdotV, roughness);\n"
                                             "    float ggx1 = GeometrySchlickGGX(NdotL, roughness);\n"
                                             "\n"
                                             "    return ggx1 * ggx2;\n"
                                             "}\n"
                                             "\n"
                                             "float GeometrySchlickGGX(float NdotV, float roughness)\n"
                                             "{\n"
                                             "	float a = roughness;\n"
                                             "	float k = (a * a) / 2.0;\n"
                                             "\n"
                                             "    float nom   = NdotV;\n"
                                             "    float denom = NdotV * (1.0 - k) + k;\n"
                                             "\n"
                                             "    return nom / denom;\n"
                                             "}\n"
                                             "\n"
                                             "vec3 fresnelSchlick(float cosTheta, vec3 F0)\n"
                                             "{\n"
                                             "    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n"
                                             "}\n"
                                             "\n"
                                             "vec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness)\n"
                                             "{\n"
                                             "    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n"
                                             "}";


    const static std::string shaderprefilterFrag = "#version 300 es\n"
                                                   "precision highp float;\n"
                                                   "out vec4 FragColor;\n"
                                                   "in vec3 FragPos;\n"
                                                   "\n"
                                                   "uniform samplerCube environmentMap;\n"
                                                   "uniform float roughness;\n"
                                                   "uniform int envRes;\n"
                                                   "\n"
                                                   "const float PI = 3.14159265359;\n"
                                                   "\n"
                                                   "float DistributionGGX(vec3 N, vec3 H, float roughness)\n"
                                                   "{\n"
                                                   "    float a = roughness*roughness;\n"
                                                   "    float a2 = a*a;\n"
                                                   "    float NdotH = max(dot(N, H), 0.0);\n"
                                                   "    float NdotH2 = NdotH*NdotH;\n"
                                                   "\n"
                                                   "    float nom   = a2;\n"
                                                   "    float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n"
                                                   "    denom = PI * denom * denom;\n"
                                                   "\n"
                                                   "    return nom / denom;\n"
                                                   "}\n"
                                                   "\n"
                                                   "// efficient Van Der Corput calculation.\n"
                                                   "float RadicalInverse_VdC(uint bits)\n"
                                                   "{\n"
                                                   "     bits = (bits << 16u) | (bits >> 16u);\n"
                                                   "     bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n"
                                                   "     bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n"
                                                   "     bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n"
                                                   "     bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n"
                                                   "\n"
                                                   "     return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n"
                                                   "}\n"
                                                   "\n"
                                                   "vec2 Hammersley(uint i, uint N)\n"
                                                   "{\n"
                                                   "	return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n"
                                                   "}\n"
                                                   "\n"
                                                   "vec3 ImportanceSampleGGX(vec2 Xi, vec3 N, float roughness)\n"
                                                   "{\n"
                                                   "	float a = roughness*roughness;\n"
                                                   "	\n"
                                                   "	float phi = 2.0 * PI * Xi.x;\n"
                                                   "	float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));\n"
                                                   "	float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n"
                                                   "	\n"
                                                   "	// from spherical coordinates to cartesian coordinates - halfway vector\n"
                                                   "	vec3 H;\n"
                                                   "	H.x = cos(phi) * sinTheta;\n"
                                                   "	H.y = sin(phi) * sinTheta;\n"
                                                   "	H.z = cosTheta;\n"
                                                   "	\n"
                                                   "	// from tangent-space H vector to world-space sample vector\n"
                                                   "	vec3 up          = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n"
                                                   "	vec3 tangent   = normalize(cross(up, N));\n"
                                                   "	vec3 bitangent = cross(N, tangent);\n"
                                                   "	\n"
                                                   "	vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n"
                                                   "	return normalize(sampleVec);\n"
                                                   "}\n"
                                                   "\n"
                                                   "void main()\n"
                                                   "{		\n"
                                                   "    vec3 N = normalize(FragPos);\n"
                                                   "    vec3 R = N;\n"
                                                   "    vec3 V = R;\n"
                                                   "\n"
                                                   "    const uint SAMPLE_COUNT = 128u;\n"
                                                   "    const float m_value = 128.0;\n"
                                                   "    vec3 prefilteredColor = vec3(0.0);\n"
                                                   "    float totalWeight = 0.0;\n"
                                                   "    \n"
                                                   "    for(uint i = 0u; i < SAMPLE_COUNT; ++i) {\n"
                                                   "        // generates a sample vector that's biased towards the preferred alignment direction (importance sampling).\n"
                                                   "        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n"
                                                   "        vec3 H = ImportanceSampleGGX(Xi, N, roughness);\n"
                                                   "        vec3 L  = normalize(2.0 * dot(V, H) * H - V);\n"
                                                   "\n"
                                                   "        float NdotL = max(dot(N, L), 0.0);\n"
                                                   "\n"
                                                   "        if(NdotL > 0.0) {\n"
                                                   "            // sample from the environment's mip level based on roughness/pdf\n"
                                                   "            float D   = DistributionGGX(N, H, roughness);\n"
                                                   "            float NdotH = max(dot(N, H), 0.0);\n"
                                                   "            float HdotV = max(dot(H, V), 0.0);\n"
                                                   "            float pdf = D * NdotH / (4.0 * HdotV) + 0.0001; \n"
                                                   "\n"
                                                   "            float saTexel  = 4.0 * PI / (6.0 * float(envRes) * float(envRes));\n"
                                                   "            float saSample = 1.0 / (m_value * pdf + 0.0001);\n"
                                                   "\n"
                                                   "            float mipLevel = roughness == 0.0 ? 0.0 : 0.5 * log2(saSample / saTexel); \n"
                                                   "            \n"
                                                   "            prefilteredColor += textureLod(environmentMap, L, mipLevel).rgb * NdotL;\n"
                                                   "            totalWeight      += NdotL;\n"
                                                   "        }\n"
                                                   "    }\n"
                                                   "\n"
                                                   "    prefilteredColor = prefilteredColor / totalWeight;\n"
                                                   "    FragColor = vec4(prefilteredColor, 1.0);\n"
                                                   "}";
    const static std::string shaderscreenVert = "#version 300 es\n"
                                                "precision highp float;\n"
                                                "layout (location = 0) in vec2 aPos;\n"
                                                "layout (location = 3) in vec2 aTexCoords;\n"
                                                "\n"
                                                "out vec2 TexCoords;\n"
                                                "\n"
                                                "void main()\n"
                                                "{\n"
                                                "    gl_Position = vec4(aPos.x, aPos.y, 0.0, 1.0); \n"
                                                "    TexCoords = aTexCoords;\n"
                                                "}";


    const static std::string shaderscreenFrag = "#version 300 es\n"
                                                "precision highp float;\n"
                                                "\n"
                                                "out vec4 FragColor;\n"
                                                "  \n"
                                                "in vec2 TexCoords;\n"
                                                "\n"
                                                "uniform sampler2D screenTexture;\n"
                                                "uniform vec2 screenSize;\n"
                                                "\n"
                                                "float FXAA_SPAN_MAX = 8.0f;\n"
                                                "float FXAA_REDUCE_MUL = 1.0f/8.0f;\n"
                                                "float FXAA_REDUCE_MIN = 1.0f/128.0f;\n"
                                                "\n"
                                                "vec3 computeToneMapping(vec2 texCoords);\n"
                                                "vec3 computeFxaa();\n"
                                                "\n"
                                                "void main()\n"
                                                "{\n"
                                                "    const float gamma = 2.2;\n"
                                                "\n"
                                                "	vec3 hdrColor = computeFxaa();\n"
                                                "\n"
                                                "	// gamma correction\n"
                                                "	hdrColor = pow(hdrColor, vec3(1.0/gamma));\n"
                                                "	FragColor = vec4(hdrColor, 1.0);\n"
                                                "}\n"
                                                "\n"
                                                "vec3 computeToneMapping(vec2 texCoords)\n"
                                                "{\n"
                                                "	const float exposure = 1.0;\n"
                                                "	vec3 hdrColor = texture(screenTexture, texCoords).xyz;\n"
                                                "	return vec3(1.0) - exp(-hdrColor * exposure);\n"
                                                "}\n"
                                                "\n"
                                                "vec3 computeFxaa()\n"
                                                "{\n"
                                                "    vec2 screenTextureOffset = 1.0 / screenSize;\n"
                                                "    vec3 luma = vec3(0.299f, 0.587f, 0.114f);\n"
                                                "\n"
                                                "    vec3 offsetNW = computeToneMapping(TexCoords.xy + (vec2(-1.0f, -1.0f) * screenTextureOffset));\n"
                                                "    vec3 offsetNE = computeToneMapping(TexCoords.xy + (vec2(1.0f, -1.0f) * screenTextureOffset));\n"
                                                "    vec3 offsetSW = computeToneMapping(TexCoords.xy + (vec2(-1.0f, 1.0f) * screenTextureOffset));\n"
                                                "    vec3 offsetSE = computeToneMapping(TexCoords.xy + (vec2(1.0f, 1.0f) * screenTextureOffset));\n"
                                                "    vec3 offsetM  = computeToneMapping(TexCoords.xy);\n"
                                                "\n"
                                                "    float lumaNW = dot(luma, offsetNW);\n"
                                                "    float lumaNE = dot(luma, offsetNE);\n"
                                                "    float lumaSW = dot(luma, offsetSW);\n"
                                                "    float lumaSE = dot(luma, offsetSE);\n"
                                                "    float lumaM  = dot(luma, offsetNW);\n"
                                                "\n"
                                                "    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)), ((lumaNW + lumaSW) - (lumaNE + lumaSE)));\n"
                                                "\n"
                                                "    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * (FXAA_REDUCE_MUL * 0.25f), FXAA_REDUCE_MIN);\n"
                                                "    float dirCorrection = 1.0f / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n"
                                                "\n"
                                                "    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * dirCorrection)) * screenTextureOffset;\n"
                                                "\n"
                                                "    vec3 resultA = 0.5f * (computeToneMapping(TexCoords.xy + (dir * vec2(1.0f / 3.0f - 0.5f))) +\n"
                                                "                                    computeToneMapping(TexCoords.xy + (dir * vec2(2.0f / 3.0f - 0.5f))));\n"
                                                "\n"
                                                "    vec3 resultB = resultA * 0.5f + 0.25f * (computeToneMapping(TexCoords.xy + (dir * vec2(0.0f / 3.0f - 0.5f))).xyz +\n"
                                                "                                             computeToneMapping(TexCoords.xy + (dir * vec2(3.0f / 3.0f - 0.5f))).xyz);\n"
                                                "\n"
                                                "    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n"
                                                "    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n"
                                                "    float lumaResultB = dot(luma, resultB);\n"
                                                "\n"
                                                "    if(lumaResultB < lumaMin || lumaResultB > lumaMax) {\n"
                                                "		return vec3(resultA);\n"
                                                "	}\n"
                                                "\n"
                                                "	return vec3(resultB);\n"
                                                "}";

    const static std::string shadersinglecolorVert = "#version 300 es\n"
                                                     "precision highp float;\n"
                                                     "layout (location = 0) in vec3 aPos;\n"
                                                     "\n"
                                                     "uniform mat4 model;\n"
                                                     "uniform mat4 view;\n"
                                                     "uniform mat4 projection;\n"
                                                     "\n"
                                                     "void main()\n"
                                                     "{\n"
                                                     "	gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
                                                     "}";
    const static std::string shadersinglecolorFrag = "#version 300 es\n"
                                                     "precision highp float;\n"
                                                     "\n"
                                                     "uniform vec3 color;\n"
                                                     "out vec4 FragColor;\n"
                                                     "\n"
                                                     "void main()\n"
                                                     "{\n"
                                                     "    FragColor = vec4(color, 1.0f);\n"
                                                     "}";

    const static std::string shaderskyboxVert = "#version 300 es\n"
                                                "precision highp float;\n"
                                                "layout (location = 0) in vec3 aPos;\n"
                                                "\n"
                                                "out vec3 TexCoords;\n"
                                                "\n"
                                                "uniform mat4 projection;\n"
                                                "uniform mat4 view;\n"
                                                "\n"
                                                "void main()\n"
                                                "{\n"
                                                "    TexCoords = aPos;\n"
                                                "    vec4 pos = projection * view * vec4(aPos, 1.0);\n"
                                                "    gl_Position = pos.xyww;\n"
                                                "}";


    const static std::string shaderskyboxFrag = "#version 300 es\n"
                                                "precision highp float;\n"
                                                "out vec4 FragColor;\n"
                                                "\n"
                                                "in vec3 TexCoords;\n"
                                                "\n"
                                                "uniform samplerCube skybox;\n"
                                                "\n"
                                                "void main()\n"
                                                "{    \n"
                                                "    FragColor = texture(skybox, TexCoords);\n"
                                                "}";


}

#endif //PBRSHADERSTRINGS_H
